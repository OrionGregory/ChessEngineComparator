# game_duel.py
import chess

botA_name = None
botB_name = None

def validate_fen(fen: str) -> bool:
    try:
        board = chess.Board(fen)
        return True
    except Exception as e:
        print(f"Invalid FEN detected: {fen} ({e})")
        return False

def validate_move(current_board, new_fen) -> bool:
    """
    Check if new_fen is reachable from current_board by exactly one legal move.
    """
    for move in current_board.legal_moves:
        board_copy = current_board.copy()
        board_copy.push(move)
        if board_copy.fen() == new_fen:
            return True
    return False

def play_single_game(game_number,
                     botA_class, botA_skill_level,
                     botB_class, botB_skill_level):
    board = chess.Board()
    move_number = 1
    # Instantiate bots.
    botA = botA_class(botA_skill_level)
    botB = botB_class(botB_skill_level)
    
    global botA_name, botB_name
    botA_name = botA.__class__.__name__
    botB_name = botB.__class__.__name__

    # Alternate colors between games.
    if game_number % 2 == 1:
        white_bot = botA
        black_bot = botB
    else:
        white_bot = botB
        black_bot = botA

    white_name = white_bot.__class__.__name__
    black_name = black_bot.__class__.__name__

    print(f"\nStarting game {game_number} -- White: {white_name} | Black: {black_name}")
    print("Initial FEN:", board.fen())
    
    while not board.is_game_over():
        current_fen = board.fen()
        print(f"Move {move_number} current FEN: {current_fen}")
        side = "Unknown"
        try:
            if board.turn == chess.WHITE:
                print(f"White ({white_name}) processing FEN...")
                new_fen = white_bot.process_fen(current_fen)
                side = f"White ({white_name})"
            else:
                print(f"Black ({black_name}) processing FEN...")
                new_fen = black_bot.process_fen(current_fen)
                side = f"Black ({black_name})"
            if not validate_fen(new_fen):
                raise ValueError(f"Invalid FEN generated by {side}: {new_fen}")
            if not validate_move(board, new_fen):
                raise ValueError(f"Illegal move detected from {side}: the FEN {new_fen} is not reachable from the current board state.")
            board = chess.Board(new_fen)
            print(f"Move {move_number} ({side}): New FEN: {new_fen}")
        except Exception as e:
            print(f"Error processing move for {side}: {e}")
            break
        move_number += 1

    result = board.result()
    print(f"Game {game_number} over. Final Board:\n{board}")
    print("Result:", result)
    
    # Determine which bot won this game (if not a draw)
    if result == "1-0":
        winner = "BotA" if (game_number % 2 == 1) else "BotB"
    elif result == "0-1":
        winner = "BotB" if (game_number % 2 == 1) else "BotA"
    else:
        winner = "Draw"

    print("Game winner:", winner)
    return result, winner

def game_duel(num_games,
              botA_class, botA_skill_level,
              botB_class, botB_skill_level):
    botA_wins = 0
    botB_wins = 0
    draws = 0

    for game in range(1, num_games + 1):
        result, winner = play_single_game(game,
                                          botA_class, botA_skill_level,
                                          botB_class, botB_skill_level)
        if winner == "BotA":
            botA_wins += 1
        elif winner == "BotB":
            botB_wins += 1
        else:
            draws += 1

        requiredgames = (num_games // 2) + 1
        # Stop early if one bot reaches the required wins.
        if botA_wins >= requiredgames or botB_wins >= requiredgames:
            print("Series decided!")
            break

    # If tied after the initial series, enter overtime elimination rounds.
    if botA_wins == botB_wins:
        print("\nSeries is tied. Entering overtime elimination rounds!")
        overtime_game = num_games + 1
        while True:
            result, winner = play_single_game(overtime_game,
                                              botA_class, botA_skill_level,
                                              botB_class, botB_skill_level)
            # Count only decisive games.
            if winner != "Draw":
                if winner == "BotA":
                    botA_wins += 1
                elif winner == "BotB":
                    botB_wins += 1
                print("Overtime game produced a winner, series decided!")
                break
            else:
                print("Overtime game was a draw, replaying...")
            overtime_game += 1

    print("\nAggregate score:")
    print(f"{botA_name} (skill={botA_skill_level}) wins (BotA): {botA_wins}")
    print(f"{botB_name} (skill={botB_skill_level}) wins (BotB): {botB_wins}")
    print("Draws:", draws)

    # Determine the final series winner and return it.
    if botA_wins > botB_wins:
        final_winner = "BotA"
    elif botB_wins > botA_wins:
        final_winner = "BotB"
    else:
        final_winner = "Draw"
    return result, final_winner

if __name__ == "__main__":
    # Example run (make sure you have a bot to test against)
    from chess_bot import ChessBot  # or use one of your uploaded bots
    game_duel(num_games=13,
              botA_class=ChessBot, botA_skill_level=1,
              botB_class=ChessBot, botB_skill_level=20)
